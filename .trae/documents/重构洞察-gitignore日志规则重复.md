# 1. 问题

项目根目录的 `.gitignore` 中，日志相关的忽略规则被重复书写两处，造成理解与维护负担，后续演进容易出现不一致。

## 1.1. **规则重复与分散**
- 涉及文件与位置：`/.gitignore` 第 4-9 行为首个日志忽略块，第 55-57 行再次出现相同的日志忽略项。
- 现象说明：相同规则重复出现（`logs/` 与 `*.log`），增加修改点数量，后续调整策略时可能只改动其中一处，导致规则不一致。
- 影响分析：
  - 可读性：读者难以判断哪个块才是“权威”的日志策略定义，增加理解时间与沟通成本。
  - 可维护性：一次变更需要在两个位置同步修改，容易遗漏。
  - 风险：当未来需要微调（例如限定只忽略根目录日志或为某模块例外），重复块使差异性难以被注意到。

代表性现状片段（节选）：
```gitignore
# 日志文件
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

...

# 日志文件
logs/
*.log
```

# 2. 收益

通过去重并集中管理日志忽略规则，提升 `.gitignore` 的清晰性和一致性，降低未来演进的认知与沟通成本。

## 2.1. **减少重复与修改点**
- 重复规则条目由 **2** 处压缩为 **1** 处，未来修改只需更改单点，审阅 diff 行数与讨论范围更集中。

## 2.2. **提升一致性与可读性**
- 统一的日志忽略块成为“单一来源”，读者不再需要在文件中来回比对，避免误解与相互覆盖的担忧。

## 2.3. **降低维护风险**
- 当需要引入例外或精细化策略时，不会因重复块导致局部不一致；评审更容易发现真实差异。

# 3. 方案

采用“去重 + 集中”的方式整理日志忽略规则，保留一处权威定义，并在注释中明确其意图与适用范围。

## 3.1. **精简并规范日志忽略块：解决“规则重复与分散”**

1) 方案概述
- 保留文件前部的日志忽略块为唯一权威来源；删除后部重复项。
- 在保留块的注释中明确当前策略的语义（例如：`logs/` 适用于任意层级的 `logs` 目录；`*.log` 适用于任意层级的日志文件）。
- 如未来需改变语义（仅忽略根目录 `logs`），可将 `logs/` 调整为 `/logs/`，但本次改动不改变语义，仅去重与规范注释。

2) 实施步骤
- 删除 `/.gitignore` 第 55-57 行重复规则（`# 日志文件`、`logs/`、`*.log`）。
- 在保留的日志块上补充简明注释，说明适用层级与常见例外写法（例如通过 `!` 前缀排除某特定文件）。
- 按既有文件的分组结构（依赖、日志、运行时、覆盖率、构建输出等）保持整体顺序，不引入语义变化。

3) 修改前代码（节选）
```gitignore
# 日志文件
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ...中间其他块...

# 日志文件
logs/
*.log
```

4) 修改后代码（节选）
```gitignore
# 日志文件（集中管理，适用于任意层级日志目录与文件）
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
```
- 说明：仅去重，未更改已有规则的匹配语义；`logs/` 与 `*.log` 的作用范围保持不变。

# 4. 回归范围

本次为配置文件的可读性与维护性优化，目标是不改变实际忽略行为。回归验证需从项目使用者视角确认 Git 忽略效果在常见场景下保持一致。

## 4.1. 主链路
- 在项目根目录与若干子目录分别创建示例文件与目录：`logs/`、`nested/logs/`、`app.log`、`nested/app.log`。
- 执行 `git status`：确认上述文件与目录均被忽略，行为与改动前一致。
- 若仓库中已跟踪某些 `.log` 文件或 `logs/` 内文件：
  - 说明：`.gitignore` 不会自动移除已跟踪文件，需人工 `git rm --cached`；验证时重点关注“新产生的”日志文件是否仍忽略。

示例用例（自然语言）：
- 预置条件：工作区干净；在 `nested/` 下新建 `app.log` 与 `logs/` 目录。
- 操作步骤：执行 `git status` 与尝试 `git add nested/app.log`。
- 期望结果：`nested/app.log` 未被暂存；`nested/logs/` 目录未被跟踪。

## 4.2. 边界情况
- 子模块或子仓库的 `.gitignore`：若存在独立子仓库，它们的忽略策略独立；本次修改不影响子仓库，但需确认顶层行为未发生变化。
- 例外规则：若未来通过 `!` 引入例外（例如 `!frontend/keep.log`），需确认例外仍生效且仅在集中块维护。
- 本地排除文件：`$GIT_DIR/info/exclude` 与全局 `~/.gitignore_global` 的交互不受本次改动影响；验证时以仓库层 `.gitignore` 为准。
